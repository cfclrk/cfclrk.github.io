#+TITLE: Using Multiple GitHub Accounts
#+SETUPFILE: ../setup.org

* The Problem

  You have multiple GitHub accounts, and you want git to automatically use the
  "right" GitHub account.

  A good way to do that is to put work-related stuff under a single directory,
  say, =~/Work=. Then, configure git to use your *work* account any project in
  your =~/Work= directory.

  In this article I set things up so that:

  - Projects in your =~/Work/= directory use your *work* GitHub account
  - Projects elsewhere use your *home* GitHub account

  My git configuration [[https://github.com/cfclrk/dotfiles/tree/master/xdg_config/git][on GitHub]] is generated from this article.

* The SSH Config
  :PROPERTIES:
  :CUSTOM_ID: the-ssh-config
  :END:

  Assuming you use the =git= protocol to clone repositories (not =https=), you
  must create at least two SSH keys for GitHub -- one for each GitHub account
  (GitHub will not allow you to use the same SSH key for both accounts). Once
  you've [[https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh][created]] those, your =~/.ssh= directory should look something like:

  #+begin_example
    $ tree ~/.ssh/
    /Users/cfclrk/.ssh/
    ├── config
    ├── github-home
    ├── github-home.pub
    ├── github-work
    └── github-work.pub
  #+end_example

  Ensure these SSH keys work:

  #+NAME: wrap
  #+header: :exports none
  #+begin_src emacs-lisp :var in=""
    (s-join "\n" (s-slice-at "but " in))
  #+end_src

  #+header: :post wrap(*this*)
  #+begin_src sh :results output
    ssh -i ~/.ssh/github-home -T git@github.com 2>&1 || true
  #+end_src

  #+RESULTS:
  : Hi cfclrk! You've successfully authenticated,
  : but GitHub does not provide shell access.

  #+header: :post wrap(*this*)
  #+begin_src sh :results output
    ssh -i ~/.ssh/github-work -T git@github.com 2>&1 || true
  #+end_src

  #+RESULTS:
  : Hi chrisc-ironnet! You've successfully authenticated,
  : but GitHub does not provide shell access.

  We don't need to modify the =~/.ssh/config= file. Instead, we'll explicitly
  tell git which SSH keys to use in our git config files.

* The Git Config

  First, tell git to use different git configurations depending on the directory
  a project is in. Git supports this with the [[https://git-scm.com/docs/git-config#_conditional_includes][includeIf]] directive. Do this by
  creating the following two files.

  =~/.config/git/config=

  #+header: :tangle ~/.config/git/config
  #+begin_src gitconfig
    [user]
        name = Chris Clark
        email = cfclrk@gmail.com
        signingkey = 80027A20FC0B6207
    [core]
        sshCommand = "ssh -i ~/.ssh/github-home"
    [commit]
        gpgsign = true
    [init]
        defaultBranch = main
    [includeIf "gitdir:~/Work/"]
        path = work.gitconfig
    [github]
        user = cfclrk
  #+end_src

  =~/.config/git/work.gitconfig=

  #+header: :tangle ~/.config/git/work.gitconfig
  #+begin_src gitconfig
    [user]
        email = chris.clark@ironnet.com
        signingkey = EDC41C0910322DD6
    [core]
        sshCommand = "ssh -i ~/.ssh/github-work"
    [github]
        user = chrisc-ironnet
  #+end_src

  Ignore the =[github]= sections; those are for [[https://github.com/magit/forge][Emacs forge]]. And of course,
  update the values for your =name=, =email=, and -- if you're using
  [[#signed-commits]] -- your PGP =signingkey= id.

  That's it for the git config! Move on to [[#signed-commits]]. The next subsection
  explains the above, if you are interested.

** More about Git Config Loading
   :PROPERTIES:
   :CUSTOM_ID: config-loading
   :END:

   Git loads /all/ applicable config files. If one option is set multiple times
   (potentially form differnt files), the last value wins.

   For example: assume you have the git config files above, which has:

   #+begin_src gitconfig
     [includeIf "gitdir:~/Work/"]
         path = work.gitconfig
   #+end_src

   Now, when you run a git command in a project located at =~/Work/projectA/=,
   git does something like:

   - Load the default =~/.config/git/config= file
     - Set =user.email= to =cfclrk@gmail.com=
   - Does =[includeIf "gitdir:~/Work/"]= apply?
     - *Yes!* Load the work.gitconfig file
     - Set =user.email= to =chris.clark@ironnet.com=

   Both the default and /work/ config files get loaded. The email address ends
   up being =chris.clark@ironnet.com= since that was the *last* value loaded for
   the =user.email= option. The determining factor is the /order in which the
   configuration is defined/, and the /last value wins/.

   If you define multiple =includeIf= directives that overwrite one another,
   specify them in order from /most general/ to /most specific/.

* Signed Commits
  :PROPERTIES:
  :CUSTOM_ID: signed-commits
  :END:

** Rationale

  Why sign commits?

  The value of =user.email= is the only piece of information GitHub uses when
  determining what profile picture to display next to a commit. You can set that
  email address to anything! E.g. set it to =torvalds@linux-foundation.org=, and
  GitHub will happily put Linus Torvalds' picture next to your git commits. And
  to be sure, [[https://news.ycombinator.com/item?id=10005577][that happens]].

  If you don't want other people impersonating you, you can /partially/ mitigate
  this problem of attribution by using [[https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work][signed commits]].

  GitHub allows you to upload a PGP key to your GitHub account, and GitHub
  displays a "Verified" badge on commits that proprely verify (i.e. =git
  verify-commit <commit>= works). For a commit to verify,

  1. The email address in the commit must match your GitHub account email
     address
  2. The commit must be signed by a PGP key that has been uploaded to
     your GitHub account

** Prerequisites

  First install the necessary tools:

  #+begin_src sh
    brew install gnupg
    brew install pinentry-mac
  #+end_src

  =pinentry-mac= saves passphrases in the MacOS keychain.

** Create PGP key

  Although GitHub [[https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key][has some instructions]] for creating a PGP key, I prefer using
  [[https://keybase.io/][keybase]].

  To use keybase, first install the [[https://keybase.io/download][native app]] (this installs the =keybase= CLI
  program).

  You /can/ import preexisting PGP keys from keybase, but it's a better idea to
  create a new PGP key for every device. To view your existing PGP keys in
  keybase:

  #+begin_src sh
    keybase pgp list
  #+end_src

  And to list your local PGP keys (this may be empty):

  #+begin_src sh
    gpg --list-secret-keys --keyid-format=long
  #+end_src

  Now, create two new PGP keys.

  TODO: Can I just use one key, and add two email addresses to it as [[https://docs.github.com/en/authentication/managing-commit-signature-verification/associating-an-email-with-your-gpg-key][described
  here]]? Or does GitHub make you use different keys for different accounts?

  Home key:

  #+begin_src sh :results output
    keybase pgp gen --multi
  #+end_src

  It will prompt you for email addresses. Add both your home and work email
  addresses.

  Add a passphrase.

  #+begin_src sh
    keybase pgp gen --multi
  #+end_src

  TODO: Should we update the trust level on each key to ultimate?

  For completeness, if you _do_ want to import a key instead of creating a new one:

  #+begin_src sh
    # Import your public pgp key
    keybase pgp export -q $keyid \
        | gpg --import
    # Import your private pgp key
    keybase pgp export -q $keyid \
            --secret \
        | gpg --allow-secret-key \
              --import
  #+end_src

** Add key ID to git config

  Get the GPG key ID of your PGP key. To get the key ID:

  #+begin_src sh :results output
    gpg --list-secret-keys --keyid-format=long
  #+end_src

  #+RESULTS:
  : /Users/cfclrk/.gnupg/pubring.kbx
  : --------------------------------
  : sec   rsa4096/80027A20FC0B6207 2022-03-14 [SC] [expires: 2038-03-10]
  :       2DEF144646C3152AE294CC5D80027A20FC0B6207
  : uid                 [ultimate] Chris Clark <cfclrk@gmail.com>
  : ssb   rsa4096/799C916E01D155A3 2022-03-14 [E] [expires: 2038-03-10]

  In the above, the key ID is =80027A20FC0B6207= (is there some command that
  prints out the key id?). Update your git config like so:

  #+begin_src gitconfig
    [user]
        signingkey = 80027A20FC0B6207
    [commit]
        gpgsign = true
  #+end_src

** Update gpg-agent.conf

  Add the following to =~/.gnupg/gpg-agent.conf=. This allows for automatic
  signing (on MacOS anyway).

  #+header: :tangle ~/.gnupg/gpg-agent.conf
  #+begin_src conf
    # Connects gpg-agent to the MacOS keychain. This enables
    # automatic key signing.
    pinentry-program /usr/local/bin/pinentry-mac
  #+end_src

** Make a git commit

   If you used a passphrase on your PGP key, your first git commit will probably
   fail. For your first git commit:

   #+begin_src bash
     export GPG_TTY=$(tty)
   #+end_src

   Now, when you make a git commit, it should prompt you for the PGP key's
   passphrase. After you do this once, you should never have to do it again.

** Add public key to GitHub

   TODO: =keybase pgp export $keyid= and =gpg --armor --export $keyid= create
   different things. Do they both work? Which is more appropriate to put in
   GitHub?

   #+begin_src sh
     keybase pgp export -q $keyid | pbcopy
   #+end_src

   Add this key to GitHub.

* More Resources

  - [[https://yayimorphology.org/ssh-identities-made-easy.html][Managing several SSH identities explained]]
