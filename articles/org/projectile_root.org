#+TITLE: Emacs Projectile in a Monorepo
#+SETUPFILE: ../setup.org

#+NAME: partition
#+begin_src emacs-lisp :var in=0 num=0 :exports none
  (-partition num in)
#+end_src

[[https://docs.projectile.mx/projectile/index.html][Projectile]] is an awesome part of Emacs -- /foundational/ even. For example,
=lsp-mode= uses Projectile to determine what directory an LSP server should be
associated with.

A minor annoyance (the bane of an Emacs user) had been nagging me. Here was the
problem:

* The Problem

  In monorepos, Projectile determines the project root to be the /monorepo/, not
  the subproject that you're in.

  When I'm in a python project that happens to be in a monorepo, I want
  Projectile to operate on the python project. I can still use Projectile on the
  whole monorepo by opening a file or Dired buffer at the root of the monorepo.

  To jump to my solution, go to [[#solution]], or see the Elisp file I use,
  generated from this document, [[https://github.com/cfclrk/dotfiles/blob/master/emacs/projectile-discovery.el][on GitHub]].

* Example of the Problem

  Consider the following monorepo:

  #+begin_src sh :exports none
    NotesProject=/tmp/repo
    mkdir -p $NotesProject
    touch $NotesProject/.git

    # Go
    mkdir -p $NotesProject/go
    mkdir -p $NotesProject/go/projectA
    touch $NotesProject/go/projectA/go.mod
    mkdir -p $NotesProject/go/projectB
    touch $NotesProject/go/projectB/go.mod

    # Python
    mkdir -p $NotesProject/python
    mkdir -p $NotesProject/python/projectC
    touch $NotesProject/python/projectC/setup.py
    mkdir -p $NotesProject/python/projectD
    touch $NotesProject/python/projectD/setup.py
  #+end_src

  #+RESULTS:

  #+begin_src sh :results output
    tree -a /tmp/repo
  #+end_src

  #+RESULTS:
  : /tmp/repo
  : ├── .git
  : ├── go
  : │   ├── projectA
  : │   │   └── go.mod
  : │   └── projectB
  : │       └── go.mod
  : └── python
  :     ├── projectC
  :     │   └── setup.py
  :     └── projectD
  :         └── setup.py
  :
  : 6 directories, 5 files

  Now when I open a file in =go/projectA=, Projectile says that the project root
  is the monorepo:

  #+header: :prologue (projectile-invalidate-cache nil)
  #+begin_src emacs-lisp
    (let ((default-directory "/tmp/repo/go/projectA"))
      (projectile-project-root))
  #+end_src

  #+RESULTS:
  : /private/tmp/repo/

  (Don't worry about the =/private/= -- it's because MacOS symlinks =/tmp= →
  =/private/tmp=).

  I /want/ Projectile to say that the project root is =/tmp/repo/go/projectA=.
  By default, however, Projectile finds the root of the monorepo.

  To understand how to change this, we need to understand how Projectile detects
  projects.

* Project Detection

  The relevant documentation is here: [[https://docs.projectile.mx/projectile/projects.html#customizing-project-detection][Customizing Project Detection]]. Projectile
  has a few strategies for finding a project root, and it tries each one in
  order. The order is defined by the variable:

  #+begin_src emacs-lisp :post partition(*this*, 1)
    projectile-project-root-functions
  #+end_src

  #+RESULTS:
  | projectile-root-local              |
  | projectile-root-bottom-up          |
  | projectile-root-top-down           |
  | projectile-root-top-down-recurring |

  The second function, =(projectile-root-bottom-up)=, is the one that is
  determining the monorepo to be the "project". See it in action:

  #+header: :prologue (projectile-invalidate-cache nil)
  #+begin_src emacs-lisp
    (projectile-root-bottom-up "/tmp/notes/go/projectA")
  #+end_src

  #+RESULTS:
  : /tmp/notes/

  Yup -- it found the monorepo, not the subproject. To understand why this is,
  let's look at [[https://github.com/bbatsov/projectile/blob/7f64570d3e6829d767d340c8584f3e4f3472ee81/projectile.el#L1124-L1129][the source]]! Here it is, slightly reformatted:

  #+begin_src emacs-lisp
    (defun projectile-root-bottom-up (dir &optional list)
      "Identify a project root in DIR by bottom-up search for
    files in LIST.

    If LIST is nil, use `projectile-project-root-files-bottom-up'
    instead. Return the first (bottommost) matched directory or nil
    if not found."
      (cl-some
       (lambda (name) (projectile-locate-dominating-file dir name))
       (or list projectile-project-root-files-bottom-up)))
  #+end_src

  In regular words, this function is doing this:

  - For each marker file in =projectile-project-root-files-bottom-up=
    - Is the file in this directory? No?
    - Is the file in the parent directory? No?
    - Is the file in the parent-parent directory? No?
    - ... etc up to =/=

  Two important takeaways:

  1. =projectile-project-root-files-bottom-up= is the variable that holds the
     list of marker files that signify a project root.
  2. The function looks for one file */all the way up to root/* before looking
     for the next file.

  And what are these "marker files"?

  #+begin_src emacs-lisp
    projectile-project-root-files-bottom-up
  #+end_src

  #+RESULTS:
  | .projectile | .git | .hg | .fslckout | _FOSSIL_ | .bzr | _darcs |

  So, assuming we're somewhere in our monorepo, Projectile starts by looking for
  a =.projectile= between here and =/=, then looks for a =.git= between here and
  =/=, finds a =.git= at =/tmp/repo/.git=, and returns =/tmp/repo=.

  To drive this point home, say we append =go.mod= to that list of marker files:

  #+begin_src emacs-lisp
    (setq projectile-project-root-files-bottom-up
          '(".projectile" ".git" ".hg" ".fslckout"
            "_FOSSIL_" ".bzr" "_darcs" "go.mod"))
  #+end_src

  #+RESULTS:
  | .projectile | .git | .hg | .fslckout | _FOSSIL_ | .bzr | _darcs | go.mod |

  Projectile still won't find our Go subproject, because =.git= comes earlier in
  the list of marker files.

  #+header: :prologue (projectile-invalidate-cache nil)
  #+begin_src emacs-lisp
    (projectile-root-bottom-up "/tmp/notes/go/projectA")
  #+end_src

  #+RESULTS:
  : /tmp/notes/

  Projectile found a =.git= two directories up before ever even looking for a
  =go.mod=. In this case we could rectify that by /prepending/ =go.mod= instead
  of appending it, but the general problem would still remain (i.e. that marker
  files several directories up could be discovered before files in the current
  directory).

  The existing behavior of the =(projectile-root-bottom-up)= function is useful
  in one situation: if you want to force a project root to a /higher/ level. For
  example, if we wanted =/tmp/= to be the project root for some reason, we could
  just put a =.projectile= there.

  #+begin_src sh :results silent
    touch /tmp/.projectile
  #+end_src

  #+header: :prologue (projectile-invalidate-cache nil)
  #+begin_src emacs-lisp
    (let ((default-directory "/tmp/notes/go/projectA"))
      (projectile-project-root))
  #+end_src

  #+RESULTS:
  : /private/tmp/

  That works! We should probably try to keep that behavior.

  #+begin_src sh :results silent :exports none
    rm /tmp/.projectile
  #+end_src

* Project Detection Issues

  So, there are two issues preventing Projectile from finding subprojects in
  our monorepo:

  1. *Marker Files*: The variable =projectile-project-root-files-bottom-up=
     doesn't have =go.mod= or =setup.py= in it.
  2. *Lookup Behavior*: Even if Projectile knows to look for =setup.py= and
     =go.mod=, the contents of directories above our project affects lookup.
     Projectile can find marker files at a higher level before looking for
     =go.mod= or =setup.py=.

  Let's examine each problem.

** Marker Files

   The problem was:

   #+begin_quote
   The variable =projectile-project-root-files-bottom-up= doesn't have =go.mod=
   or =setup.py= in it.
   #+end_quote

   We just need to add =setup.py= and =go.mod= to the list of marker files.
   While we're at it, let's add every other filename that indicates a project
   root. Projectile already has a variable for this, documented in [[https://docs.projectile.mx/projectile/projects.html#file-markers][File markers]]:

   #+header: :post partition(*this*, 4)
   #+begin_src emacs-lisp
     projectile-project-root-files
   #+end_src

   #+RESULTS:
   | dune-project           | pubspec.yaml   | info.rkt     | Cargo.toml     |
   | stack.yaml             | DESCRIPTION    | Eldev        | Cask           |
   | shard.yml              | Gemfile        | .bloop       | deps.edn       |
   | build.boot             | project.clj    | build.sc     | build.sbt      |
   | application.properties | gradlew        | build.gradle | pom.xml        |
   | poetry.lock            | Pipfile        | tox.ini      | setup.py       |
   | requirements.txt       | manage.py      | angular.json | package.json   |
   | gulpfile.js            | Gruntfile.js   | mix.exs      | rebar.config   |
   | composer.json          | CMakeLists.txt | Makefile     | debian/control |
   | WORKSPACE              | flake.nix      | default.nix  | meson.build    |
   | SConstruct             | GTAGS          | TAGS         | configure.ac   |

   Decent start, but it doesn't have =go.mod=, so we should add that. Might as
   well also add all the files in =projectile-project-root-files-bottom-up=
   (which has =.git=, etc). I also add =requirements.txt=, which is a useful way
   for me to demarcate a small Python example (like a GitHub Gist) that maybe
   doesn't warrant a whole =setup.py=.

   #+begin_src emacs-lisp :results silent
     (setq my-project-root-files
           (-concat '("go.mod" "requirements.txt")
                    projectile-project-root-files-bottom-up
                    projectile-project-root-files))
   #+end_src

   That creates a pretty complete list of marker files that can indicate project
   roots.

** Lookup Behavior

   The problem was:

   #+begin_quote
   Even if Projectile knows to look for =setup.py= and =go.mod=, the contents of
   directories above our project affects lookup. Projectile can find marker
   files at a higher level before looking for =go.mod= or =setup.py=.
   #+end_quote

   Instead, we want to look for for /every/ marker file in the current directory
   before continuing to a parent directory.

   Instead of looping over the marker files and running =locate-dominating-file=
   on each filename, we should loop over the /directories/ (starting from the
   bottom) and check whether any maker file is in that directory.

   The [[https://github.com/rejeep/f.el][f]] library already has a perfect function for that: [[https://github.com/rejeep/f.el#f-traverse-upwards-fn-optional-path][f-traverse-upwards]].

* File Header                                                      :noexport:

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :exports none
    ;;; projectile-discovery.el -- My project discovery config -*- lexical-binding: t; -*-

    ;;; Commentary:

    ;; Update projectile's project discovery behavior in monorepos to consider
    ;; subprojects as project roots, rather than considering the monorepo root as
    ;; the project root.

    ;; See: https://www.cfclrk.com/articles/projectile_root.html

    ;; This file is tangled from
    ;; https://github.com/cfclrk/cfclrk.github.io/blob/main/articles/org/projectile_root.org

    ;;; Code:
  #+end_src

* Solution
  :PROPERTIES:
  :CUSTOM_ID: solution
  :END:

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp
    (require 'projectile)
    (require 'f)
  #+end_src

  We will define a new strategy for discovering projects. First, define a
  variable with the marker files that indicate a project root.

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :results silent
    (setq my-project-root-files
          (-concat '("go.mod" "requirements.txt")
                   projectile-project-root-files-bottom-up
                   projectile-project-root-files))
  #+end_src

  Define a new discovery function.

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :results silent
    (defun any-file-exists? (files dir)
      "True if any of the filenames in FILES is in DIR.
    FILES is a list of filenames. DIR is a path to a directory."
      (cl-some
       (lambda (filename) (f-exists? (f-expand filename dir)))
       files))
  #+end_src

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :results silent
    (defun my-project-root (dir &optional list)
      "Identify a project root.
    Perform a bottom-up search for files in LIST starting from DIR.
    Always return the lowest directory that has any file in LIST. If
    LIST is nil, use `my-project-root-files' instead. Return the
    first (bottommost) matched directory or nil."
      (let ((marker-files (or list my-project-root-files)))
        (f--traverse-upwards (any-file-exists? marker-files it)
                             dir)))
  #+end_src

  Insert our new lookup function into =projectile-project-root-functions=.

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :results silent
    (setq projectile-project-root-functions
          '(projectile-root-local
            projectile-root-bottom-up
            my-project-root  ;;  Our new function
            projectile-root-top-down
            projectile-root-top-down-recurring))
  #+end_src

  Restrict Projectile's original bottom-up discovery to only work for
  =.projectile= files. This allows us to force a project root to a higher level
  by creating a =.projectile= file.

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :results silent
    (setq projectile-project-root-files-bottom-up
          '(".projectile"))
  #+end_src

* Test

  After applying the functions above, let's see what Projectile says the project
  roots are for our monorepo.

** Go

   Can we correctly identify a Go project?

   #+header: :prologue (projectile-invalidate-cache nil)
   #+begin_src emacs-lisp
     (let ((default-directory "/tmp/notes/go/projectA"))
       (projectile-project-root))
   #+end_src

   #+RESULTS:
   : /private/tmp/notes/go/projectA

** Python

   Can we correctly identify a Python project?

   #+header: :prologue (projectile-invalidate-cache nil)
   #+begin_src emacs-lisp
     (let ((default-directory "/tmp/notes/python/projectC"))
       (projectile-project-root))
   #+end_src

   #+RESULTS:
   : /private/tmp/notes/python/projectC

** Force Root Higher

   Can we force the project root to a higher level by creating a =.projectile=
   file?

   #+begin_src sh :results silent
     touch /tmp/repo/.projectile
   #+end_src

   #+header: :prologue (projectile-invalidate-cache nil)
   #+begin_src emacs-lisp
     (let ((default-directory "/tmp/repo/go/projectA"))
       (projectile-project-root))
   #+end_src

   #+RESULTS:
   : /private/tmp/repo/

   #+begin_src sh :results silent :exports none
     rm /tmp/repo/.projectile
   #+end_src

* File Footer                                                      :noexport:

  #+header: :tangle (expand-file-name "~/Projects/dotfiles/emacs/projectile-discovery.el")
  #+begin_src emacs-lisp :exports none
    ;;; projectile-discovery.el ends here
  #+end_src
