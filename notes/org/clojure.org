#+TITLE: Clojure
#+SETUPFILE: ../setup.org

* Installation

  The clojure site [[https://clojure.org/guides/getting_started#_clojure_installer_and_cli_tools][suggests]] using the following:

  #+begin_src sh
    brew install clojure/tools/clojure
  #+end_src

  There is also a slightly different [[https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/clojure.rb][formula in homebrew core]]:

  #+begin_src sh
    brew install clojure
  #+end_src

  This one =depends_on "openjdk"=, so it will also install the latest =openjdk=
  homebrew package. The first method is preferred, which requires you to set up
  and configure a JDK yourself.

* clj vs clojure

  =clj= is just a program that wraps =clojure= with =readline= support.

  #+begin_src bash :results output
    find /usr/local/Cellar/clojure -name clj \
        | sed -n '2 p' \
        | xargs cat \
        | grep exec
  #+end_src

  #+RESULTS:
  :   exec rlwrap -r -q '\"' -b "(){}[],^%#@\";:'" "$bin_dir/clojure" "$@"

  =readline= provides support for editing a command in the terminal (e.g. using
  arrow keys and =C-a= =C-e= =C-f= =C-b= for movement, and stuff like that.

  So, =clj= just provides better interactivity in the terminal REPL.

* Tools

  Ok, so there is:

  1. tools.build
  2. tools.tools


  From the [[https://clojure.org/guides/tools_build][tools.build guide]]:

  #+begin_quote
  In the Clojure CLI, "tools" are programs that provide functionality and do not
  use your project deps or classpath. Tools executed with =-T:an-alias= remove
  all project deps and paths, add "=.=" as a path, and include any other deps or
  paths as defined in =:an-alias=.
  #+end_quote

** Where do tools live?

   Defined by an alias in =deps.edn=.

* Cmd Execution and REPL

  Call a single function

  #+header: :dir ~/Projects/codenotes/clojure/scratch
  #+header: :var nsname="hello" funcname="foo"
  #+begin_src sh :results output
    clj -X $nsname/$funcname
  #+end_src

  #+RESULTS:
  : Hello world, the time is 10:00 AM

  Start a REPL that I can attach to from Emacs.

  #+begin_src sh
    clj -Sdeps '{:deps {cider/cider-nrepl {:mvn/version "RELEASE"}}}' \
        -m nrepl.cmdline \
        --middleware "[cider.nrepl/cider-middleware]"
  #+end_src

* Project Creation

** Minimal

   All you need is a project directory with a =deps.edn= and a =src/foo.clj=.
   However it should be namespaced properly (TODO: work on this).

   #+begin_src sh :var d="helloworld"
     touch $d/deps.edn $d/src/core.clj
     echo "{:deps {org.clojure/clojure {:mvn/version \"RELEASE\"}}}" > $d/deps.edn
     echo "(ns core) (defn -main [] (println \"hello world\"))" >> src/core.clj
     clj -m core
   #+end_src

** Leiningen

   #+header: :dir ~/Projects/codenotes/clojure
   #+header: :var projectName="minesweeper"
   #+begin_src sh :results output
     lein new app cfclrk/$projectName
   #+end_src

** deps-new

   First, make sure [[https://github.com/seancorfield/deps-new][deps-new]] is installed:

   #+begin_src sh :results output
     clojure -Ttools install \
         io.github.seancorfield/deps-new \
         '{:git/tag "v0.4.9"}' :as new
   #+end_src

   Create a new app:

   #+header: :dir ~/Projects/codenotes/clojure
   #+header: :var projectName="ring-compojure"
   #+begin_src sh
     clojure -Tnew app :name cfclrk/$projectName
   #+end_src

   Create a new lib:

   #+begin_src sh
     clojure -Tnew lib :name cfclrk/$projectName
   #+end_src

* Emacs Cider

  Basic workflow is described [[https://docs.cider.mx/cider/usage/cider_mode.html#basic-workflow][in the cider docs here]].

  - Open a file in the project
  - =M-x cider-jack-in=
  - Load a project file using =C-c C-k= (=cider-load-buffer=)
  - In the =*cider-repl= buffer, you know call the fully-qualified functions in
    that file.
    - Or, =(in-ns 'the.ns.name)= to call functions in that file without
      namespace qualification.
    - Then also =(use 'clojure.core)= and =(use 'clojure.repl)='
  - Edit a function, and =C-c C-e= on that function to reload it.

** Tips

  - From source file, =C-u C-c C-z= to jump to cider buffer already namespaced
    to the source file.
  - Quit a long-running eval with =C-c C-b= (=cider-interrupt=).

** Doc

   Function doc: =C-c C-d C-d= (=cider-doc=)

* Testing

  Use test-runner, which handles test discovery and running tests.
  https://github.com/cognitect-labs/test-runner

** Run all tests in namespace

   #+begin_src sh
     clj -A:test -n cfclrk.sicp-test
   #+end_src

** Run a single test

   #+begin_src sh
     clj -A:test -v cfclrk.sicp-test/a-test
   #+end_src

* Symbols vs Keywords

  What's the difference between a quoted symbol and a keyword?

  Excerpt from "Clojure in Action, Second Edition" by Amit Rathore Francis
  Avila:

  #+begin_quote
  Essetially what's happening when you quote a symbol is you’re treating the
  symbol as data and not code. In practice you’ll almost never quote symbols to
  use them as data because Clojure has a special type specifically for this use
  case: the keyword. A keyword is sort of like an autoquoted symbol: keywords
  never reference some other value and always evaluate to themselves. Keyword
  syntax is almost like symbol syntax, except keywords always begin with a
  colon.
  #+end_quote

* Quickies

** Print environment variables

   #+begin_src clojure
     (doseq [[k v] (System/getenv)] (println k v))
   #+end_src

* core.async

  There are some great examples from O'Reilly [[https://resources.oreilly.com/examples/0636920041474/][here]], which is supplemental
  content for their excellent video course [[https://learning.oreilly.com/videos/communicating-sequential-processes/9781771374293/][Communicating Sequential Processes
  with core.async]].
